
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
</head>
<body>
<pre>
compound_stmt ::= IGNORE
</pre>

if_stmt ::=  "if" expression ":" suite
             ( "elif" expression ":" suite )*
             ["else" ":" suite]
an else:... clause may change status depending on the connection.
When after a try:..., there can be a finally:... after
but when after an if:..., no finally:... is allowed.
'A B0F B' means that block A comes to the bottom of block B
'A T0F B' means that block A comes on top of block B
'A R0F B' means that block A comes to the right of block B
'A L0F B' means that block A comes to the left of block B
For example, decorations come on top of definitions,
whereas elif comes below if or other elif.
Rules are cumulative, which means that A T0F B and A T0F C significates that A comes just on top of B or C.
<pre>
if_stmt ::= IGNORE
if_part/if ::= "if" expression ":"
elif_part/elif ::= "elif" expression ":"
else_part/else ::= "else" ":"
last_else_part ::= else_part # this block type is never used in a definition, only for checking
else_part B0F if_part | elif_part | any_stmt
simple_stmt R0F if_part | elif_part | else_part | last_else_part
last_else_part B0F if_part | elif_part | any_stmt
elif_part B0F if_part | elif_part | any_stmt
</pre>
<pre>
while_stmt ::= IGNORE
while_part/while ::=  "while" expression ":"
else_part B0F while_part
last_else_part B0F while_part
simple_stmt R0F while_part
</pre>
<pre>
for_stmt ::= IGNORE
for_part/for ::=  "for" target_list "in" expression_list ":"
else_part B0F for_part
last_else_part B0F for_part
simple_stmt R0F for_part
</pre>
try_stmt  ::=  try1_stmt | try2_stmt
try1_stmt ::=  "try" ":" suite
               ("except" [expression ["as" identifier]] ":" suite)+
               ["else" ":" suite]
               ["finally" ":" suite]
try2_stmt ::=  "try" ":" suite
               "finally" ":" suite
<pre>
try_stmt ::= IGNORE
try1_stmt ::= IGNORE
try2_stmt ::= IGNORE
try_part/try
except_part/except
void_except_part ::= "except" ":" # this block type is never used in a definition, only for checking
finally_part/finally
try_part T0F except_part | void_except_part | finally_part | any_stmt
void_except_part B0F except_part
except_part B0F try_part | except_part | any_stmt
void_except_part B0F try_part | except_part | any_stmt
try_else_part/else ::= else_part # this block type is never used in a definition, only for checking
else_part B0F except_part | void_except_part | any_stmt
try_else_part B0F except_part | void_except_part | any_stmt
finally_part B0F try_part | except_part | void_except_part | try_else_part | else_part | any_stmt
simple_stmt R0F try_part | except_part | void_except_part | try_else_part | finally_part
</pre>

with_stmt ::=  "with" with_item ("," with_item)* ":" suite
with_item ::=  expression ["as" target]

<pre>
with_stmt ::= IGNORE
with_part/with ::= "with" with_item_list ":"
with_item_list ::= with_item ("," with_item)*
with_item ::=  expression | expression_as
expression_as ::= expression "as" target
simple_stmt R0F with_part
</pre>
If a parameter has a default value, all following parameters up until the “*” must also have a default value — this is a syntactic restriction that is not expressed by the grammar.


<pre>
funcdef ::= REMOVE
async_funcdef ::= REMOVE
funcdef_part/function ::= ["async"] "def" funcname "(" [parameter_list] ")" ["->" expression] ":" SUITE
decorators ::= REMOVE
decorator ::= REMOVE
decorator_stmt ::= "@" dotted_name ["(" [argument_list [","]] ")"] NEWLINE
decorator_stmt T0F decorator_stmt | funcdef_part
simple_stmt R0F funcdef_part
</pre>


parameter_list ::=  parameter_list_1 | parameter_list_2| parameter_list_starargs
parameter_list_1 ::= defparameter ("," defparameter)*
parameter_list_2 ::= defparameter ("," defparameter)* "," parameter_list_starargs

parameter_list_starargs ::=  "*" [parameter] ("," defparameter)* ["," ["**" parameter [","]]]
                             | parameter_list_starargs_b
parameter_list_starargs_a ::=  "*" [parameter] ("," defparameter)* ["," ["**" parameter [","]]]
parameter_list_starargs_b ::=  "**" parameter [","]

parameter_list          ::=  defparameter ("," defparameter)* ["," [parameter_list_starargs]]
                             | parameter_list_starargs
parameter_list_starargs ::=  "*" [parameter] ("," defparameter)* ["," ["**" parameter [","]]]
                             | "**" parameter [","]
parameter               ::=  identifier [ ":" expression ]
defparameter            ::=  parameter | parameter "=" expression

From the grammar

parameters: '(' [typedargslist] ')'
typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [
        '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
      | '**' tfpdef [',']]]
  | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
  | '**' tfpdef [','])
tfpdef: NAME [':' test]
varargslist: (vfpdef ['=' test] (',' vfpdef ['=' test])* [',' [
        '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]
      | '**' vfpdef [',']]]
  | '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]
  | '**' vfpdef [',']
)
vfpdef: NAME

modulo [',']

typedargslist:
tfpdef ['=' test] (',' tfpdef ['=' test])*
| tfpdef ['=' test] (',' tfpdef ['=' test])* ',' '*' [tfpdef] (',' tfpdef ['=' test])*
| tfpdef ['=' test] (',' tfpdef ['=' test])* ',' '*' [tfpdef] (',' tfpdef ['=' test])* ',' '**' tfpdef
| '*' [tfpdef] (',' tfpdef ['=' test])*
| '*' [tfpdef] (',' tfpdef ['=' test])* ',' '**' tfpdef
| '**' tfpdef

parameter_list ::=
| defparameter (',' defparameter)*
| defparameter (',' defparameter)* ',' '*' [tfpdef] (',' defparameter)*
| defparameter (',' defparameter)* ',' '*' [tfpdef] (',' defparameter)* ',' '**' tfpdef
| defparameter (',' defparameter)* ',' '**' tfpdef
| '**' tfpdef

<pre>
parameter_list ::= 
star ::= "*"
parameter_star ::= "*" parameter
parameter_star_star ::= "**" parameter
parameter_any ::= parameter | defparameter | star | parameter_star | parameter_star_star
identifier_annotated     ::=  identifier ":" expression
identifier_valued       ::=  identifier "=" expression
identifier_annotated_valued ::=  identifier_annotated "=" expression
parameter               ::=  identifier | identifier_annotated
defparameter            ::=  parameter | identifier_valued | identifier_annotated_valued
</pre>

classdef    ::=  [decorators] "class" classname [inheritance] ":" suite
classname   ::=  identifier

<pre>
classdef ::= IGNORE
classdef_part/class ::=  "class" classname ['(' argument_list ')'] ':'
decorator T0F classdef_part
simple_stmt R0F classdef_part
</pre>

<pre>
docstring_stmt ::= longstringliteral +{1}
</pre>

<pre>
async_with_stmt ::= REMOVE
async_for_stmt ::= REMOVE
</pre>

</body>
</html>