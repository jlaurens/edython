#! /usr/bin/env python
"""
Translate graminit.c into graminit.js
"""
import os, re

class IO:

  def __init__(self):
    self.line = None
    self.out = []
    self.m = None
    self.in_label = False
    self.in_grammar = False
    self.t_by_index = {}
    self.nt_by_index = {}
    self.dfa_by_index = {}
    self.tokens = []
    self.labels = []
    self.end_states = None

  def append(self, str):
    self.out.append(str)

io = IO()
io.append("""/* Generated by ./graminit.py */
goog.require('eYo.GMR')
goog.require('eYo.BitSet')
goog.provide('eYo.GMR.Init')
""")

rc1 = re.compile('^/\*.*')

def mc1(io):
  io.append(io.line)

rc2 = re.compile('^#.*')

def mc2(io):
  io.append('//')
  io.append(io.line)

rc3 = re.compile('^grammar.*;.*')

mc3 = mc2

#static arc arcs_0_0[3] = {
rc4 = re.compile(r'^static arc arcs_(\d+_\d+)(\[\d+\]) = \{')

def mc4(io):
  io.append(f'var /* static arc */ arcs_{io.m.group(1)}/*{io.m.group(2)}*/ = [ // LABEL_arcs_{io.m.group(1)}\n')

#    {2, 1},
rc5 = re.compile(r'^\s*\{\s*(\d+)\s*,\s*(\d+)\s*\}\s*,\s*$')

def mc5(io):
  if io.in_label:
    io.labels.append(f'{io.m.group(1)}')
    if io.m.group(2) != '0':
      io.append(f'  l({io.m.group(1)}, {io.m.group(2)}),')
    else:
      io.append(f'  l({io.m.group(1)}),')
    try:
      name = io.t_by_index[io.m.group(1)]
      io.append(f' // {name}')
    except:
      pass
  else:
    io.append(f'  a({io.m.group(1)}, {io.m.group(2)}), // LABEL')
  io.append('\n')

#};
rc6 = re.compile(r'^\s*\}\s*;\s*$')

def mc6(io):
  x = ')' if io.in_grammar else ']'
  io.append(f'{x}\n')
  if io.end_states is not None:
    io.append(f'states_{io.end_states}.d_name = "D_NAME_{io.end_states}"\n')
    io.end_states = None


#static state states_0[3] = {
rc7 = re.compile(r'^\s*static\s+state\s+states_(\d+)\s*(\[\s*\d+\s*\])\s*=\s*\{\s*$')

def mc7(io):
  io.end_states = io.m.group(1)
  io.append(f'var /* static state */ states_{io.m.group(1)}/*{io.m.group(2)}*/ = [ // LABEL_states_{io.m.group(1)}\n')

#    {3, arcs_0_0},
rc8 = re.compile(r'^\s*\{\s*\d+\s*,\s*(arcs_\d*_\d+)\s*\}\s*,\s*$')

def mc8(io):
  io.append(f'  s({io.m.group(1)}),\n')

# static dfa dfas[92] = {
rc9 = re.compile(r'^\s*static\s+dfa\s+dfas\s*(\[\s*\d+\s*\])\s*=\s*\{\s*$')

def mc9(io):
  io.append(f'var /* static dfa */ dfas/*{io.m.group(1)}*/ = [\n')

#    {256, "single_input", 0, 3, states_0,
rc10 = re.compile(r'^\s*\{\s*(\d+\s*,\s*"([^"]*)"\s*,\s*\d+\s*,\s*\d+\s*,\s*states_(\d+)\s*,)\s*$')

def mc10(io):
  io.dfa_by_index[io.m.group(3)] = io.m.group(2)
  io.append(f'  d({io.m.group(1)}\n')

#"\004\050\340\000\004\000\000\000\024\174\022\016\204\045\000\041\000\000\014\211\362\041\010"},
rc11 = re.compile(r'^\s*"((?:\\\d{3})+)"\s*\}\s*,\s*$')

def mc11(io):
  io.append('    b(')
  ra = [eval(f'0o{m.group(1)}') for m in re.finditer(r'\\(\d{3})', io.m.group(1))]
  for x in ra:
    io.append(f'{x}, ')
  io.append(f')),\n')

#static label labels[184] = {
rc12 = re.compile(r'^\s*static\s+label\s+labels\s*(\[\s*\d+\s*\])\s*=\s*\{\s*$')

def mc12(io):
  io.in_label = True
  io.append(f'var /* static label */ labels/*{io.m.group(1)}*/ = [\n')

#    {0, "EMPTY"},
rc13 = re.compile(r'^\s*\{\s*(\d+)\s*,\s*("[^"]+")\s*\}\s*,\s*$')

def mc13(io):
  io.labels.append(f'kw({io.m.group(2)})')
  io.append(f'  l({io.m.group(1)}, {io.m.group(2)}),\n')

#grammar _PyParser_Grammar = {
rc14 = re.compile(r'^\s*grammar\s+_PyParser_Grammar\s+=\s+\{\s*$')

def mc14(io):
  io.append(f'eYo.GMR._PyParser_Grammar = new eYo.GMR(\n')
  io.in_grammar = True

#    92,...
rc15 = re.compile(r'^\s*((\d+)\s*,|dfas\s*,|\s*,|\d+?)\s*$')

def mc15(io):
  if io.m.group(2) is None:
    io.append(f'  {io.m.group(1)}\n')

#    {..., labels},
rc16 = re.compile(r'^\s*\{.*,\s*labels\s*\}\s*,\s*$')

def mc16(io):
  io.append(f'  labels,\n')

rc_s = [rc1, rc2, rc3, rc4, rc5, rc6, rc7, rc8, rc9,
rc10, rc11, rc12, rc13, rc14, rc15, rc16]
mc_s = [mc1, mc2, mc3, mc4, mc5, mc6, mc7, mc8, mc9,
mc10, mc11, mc12, mc13, mc14, mc15, mc16]

rh1 = rc1

mh1 = mc1

##define single_input 256

rh2 = re.compile(r'^#define\s+(\S+)\s+(\d+)\s*$')

def mh2(io):
  io.t_by_index[io.m.group(2)] = io.m.group(1)
  io.nt_by_index[io.m.group(2)] = io.m.group(1)
  io.append(f'  {io.m.group(1)}: {{ value: {io.m.group(2)} }},\n')

rh_s = [rh1, rh2]
mh_s = [mh1, mh2]

#ENDMARKER = 0
rt1 = re.compile(r'^(\S+)\s+=\s+(\d+)\s*$')

def mt1(io):
  io.t_by_index[io.m.group(2)] = io.m.group(1)

rt_s = [rt1]
mt_s = [mt1]

dest = os.path.dirname(__file__)
try:
  with open(os.path.join(dest, '../Lib/token.py'), 'r') as f:
    for io.line in f.readlines():
      for i in range(len(rt_s)):
        io.m = rt_s[i].match(io.line)
        if io.m is not None:
          mt_s[i](io)
          break

# open file 'graminit.h' for reading
  with open(os.path.join(dest, 'graminit.h'), 'r') as f:
    io.append("""Object.defineProperties(eYo.TKN, {
""")
    done = False
    for io.line in f.readlines():
      for i in range(len(rh_s)):
        io.m = rh_s[i].match(io.line)
        if io.m is not None:
          mh_s[i](io)
          break
      else:
        if not done and len(io.line) > 1:
          done = True
          print(io.line.rstrip())
    io.append("""})
""")
  io.append("""Object.defineProperties(eYo.TKN, {
  _NT_NAMES: {
    value: [
""")
  for k in sorted(io.nt_by_index.keys()):
    io.append(f"""     '{io.nt_by_index[k]}',
""")
  io.append("""   ]
  }
})
""")
  with open(os.path.join(dest, 'graminit.c'), 'r') as f:
    io.append(""";(function() {
  var a = (lbl, arrow) => new eYo.GMR.Arc(lbl, arrow)
  var s = (arcs) => new eYo.GMR.State(arcs)
  var d = (type, name, initial, n_states, states, first) => new eYo.GMR.DFA(type, name, initial, states, first)
  var b = (...args) => {
    var ss = new eYo.BitSet(args.length * 8)
    for (var i = 0 ; i < args.length ; i++) {
      ss.ra[i] = args[i]
    }
    return ss
  }
  var l = (type, str) => new eYo.GMR.Label(type, str || null)
""")
    done = False
    for io.line in f.readlines():
      for i in range(len(rc_s)):
        io.m = rc_s[i].match(io.line)
        if io.m is not None:
          mc_s[i](io)
          break
      else:
        if not done and len(io.line) > 1:
          done = True
          print(io.line.rstrip())
    io.append("""})()
""")
  out = ''.join(io.out)
  r = re.compile
  def repl(m):
    key = io.labels[int(m.group(2))]
    if key in io.t_by_index:
      return m.group(1) + ' // ' + io.t_by_index[key]
    mm = re.match('.*"(.*)".*', key)
    if mm is not None:
      return m.group(1) + ' // ' + mm.group(1)
    return m.group(1)

  out = re.sub(r'(\ba\s*\((\d+)\s*,\s*\d+\s*\)\s*,)\s*//\s*LABEL', repl, out)
  
  def repl(m):
    try:
      return ' // ' + io.dfa_by_index[m.group(1)]
    except:
      print(f'No DFA for {m.group(1)}')
      return ""
  out = re.sub(r'\s*//\s*LABEL_(?:arcs|states)_(\d+).*', repl, out)

  def repl(m):
    try:
      return f' "{io.dfa_by_index[m.group(1)]}"'
    except:
      print(f'No DFA for {m.group(1)}')
      return '""'
  out = re.sub(r'\s*"D_NAME_(\d+)".*', repl, out)

  with open(os.path.join(dest, 'graminit.js'), 'w') as f:
    f.write(out)
  print('Done')
except OSError as err:
  import sys, tempfile, logging
  import urllib.request
  def download(url, base):
    u = urllib.request.urlopen(url)
    filename = os.path.join(dest, base)
    with open(filename, 'wb') as f:
      meta = u.info()
      meta_func = meta.getheaders if hasattr(meta, 'getheaders') else meta.get_all
      meta_length = meta_func("Content-Length")
      file_size = None
      if meta_length:
        file_size = int(meta_length[0])
      print("Downloading: {0} Bytes: {1}".format(url, file_size))

      file_size_dl = 0
      block_sz = 8192

      while True:
        buffer = u.read(block_sz)
        if not buffer:
          break

        file_size_dl += len(buffer)
        f.write(buffer)

        status = "{0:16}".format(file_size_dl)
        if file_size:
          status += "   [{0:6.2f}%]".format(file_size_dl * 100 / file_size)
        status += '\n'
        print(status, end="")
  download('https://raw.githubusercontent.com/python/cpython/master/Include/graminit.h', 'graminit.h')
  download('https://raw.githubusercontent.com/python/cpython/master/Python/graminit.c', 'graminit.c')
  download('https://raw.githubusercontent.com/python/cpython/master/Lib/token.py', '../Lib/token.py')
  print('Maybe you should check code consistency')
  print('Then run `npm run eyo:graminit`')
