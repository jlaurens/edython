"""
Utilities to extract or update inline tests
"""

from .path import *
from .termformat import *

import re, datetime
from pathlib import Path
from collections import OrderedDict

# //<<< _type_: _what_
re_begin = re.compile(r"""^\s*//<<<\s*(?:(?P<type>.*?)\s*:\s*)?(?P<begin>.*?)\s*$""", re.X)
# //... blah blah blah
re_cont = re.compile(r"""^\s*//\.\.\.(?P<indent>\s*)(?P<cont>.*?(?P<chai>\bchai\.(?:expect|assert|should)\b)?.*)\s*$""", re.X)
# //>>>
re_end = re.compile(r"""^\s*//>>>""", re.X)
# |||
re_it = re.compile(r"""\s*\|\|\|\s*""", re.X)

class Line:
  """
  Records various attributes of lines.
  """

  def __init__(self, n, l):
    self.describe = False
    self.n = self.type = self.cont = self.code = self.indent = self.end = self.begin = self.what = self.raw = None
    self.chai = False
    self.header = False
    m = re_begin.match(l)
    if m:
      self.n = n
      self.type = m.group('type')
      self.begin = m.group('begin')
      self.raw = '...' == self.begin
      what = re_it.split(l.begin)
      if what[0] == '':
        what = ('Basics')
      l.what = what
      print(f're_begin at {n}, {l.rstrip()}')
      print(f'{self.type}: {self.begin} / {self.raw}')
      return
    m = re_cont.match(l)
    if m:
      self.n = n
      self.cont = m.group('cont')
      self.chai = m.group('chai') is not None
      self.indent = m.group('indent')
      #print(f're_cont at {n}, {l.rstrip()}')
      return
    m = re_end.match(l)
    if m:
      self.n = n
      #print(f're_end at {n}, {l.rstrip()}')
      return
    #print(f'other at {n}, {l.rstrip()}')
    self.code = l.rstrip()


def extract_inline_test():
  print(format.title('Extracting inline tests...'))
  for p_test in get_tests_js():
    print(p_test.relative_to(path_js))
    p_ext = p_test.suffix
    p_base = p_test.parent / (p_test.stem.split('.')[0])
    p_js = p_base.with_suffix(p_ext)
    it = getInlineTest(p_js)
    p_inline = p_base.with_suffix('.test.inline' + p_ext)
    if len(it):
      p_inline.write_text(f'// This file was generated by "test.py" on {datetime.datetime.utcnow()}\n\n' + it)
    else:
      try:
        p_inline.unlink()
      except FileNotFoundError:
        pass
  print(format.ok('... DONE'))

def get_header_count(lines):
  header_count = 0 # no header comment recognized
  for line in lines:
    if line.code.startswith('/**'):
      header_count = 1
      line.header = True
    elif header_count and line.code.startswith(' */'):
      header_count += 1
      line.header = True
      break
    elif header_count and line.code.startswith(' *'):
      header_count += 1
      line.header = True
    elif line.code.startswith('/*'):
      break
    elif line.code.startswith('//'):
      break
    else:
      print('header_count: ', header_count)
      raise Exception(f'{path}: File must start with `/*` or `//`, got: {line.code}')
  return header_count

def prepare_test_lines(lines):
  stack = [] # the stack of begin lines
  l_start = None # the current begin line 
  l_chai = False # Did I parse a chai line
  indent = None
  raw = None
  for l in lines:
    if l.begin is not None:
      assert not l_chai, f'''Missing a '//>>>' line before line {l.n} at {path}'''
      assert not raw or not l.raw, f'''Only raw inline tests groups may be nested {l.n} at {path}'''
      if l_start is not None:
        l_start.describe = True
      stack.append(l_start)
      l_start = l
      indent = None
      raw = l.raw
    elif l.n is not None:
      if l_chai:
        assert l_start is not None, f'''Missing a '//<<<' line before line {l.n} at {path}'''
      if l_start:
        l.what = l_start.what
      if l.chai and not raw:
        l_chai = True
      elif l.cont is None:
        l_chai = False
        l.raw = raw
      if l.indent is None:
        assert len(stack), f'''Missing a '//<<<' line before line {l.n} at {path}'''
        l_start = stack.pop()
        l_chai = False
        raw = False
      elif indent is None:
        indent = l.indent
        l.indent = ''
      elif len(indent) <= len(l.indent):
        l.indent = l.indent[len(indent):]

  assert l_start is None, f'''Missing a '//>>>' line after line {lines[-1].n} to close '//<<<' at line {l_start.n} in {path}'''

def getInlineTest(path):
  # read all the lines
  # record the line number and
  # parse for inline testing
  lines = []
  with path.open() as f:
    for l in f:
      lines.append(Line(len(lines)+1, l))
  # We will replace the header comment lines by some test related code
  # In order to have the very same line number, we have
  # to replace 7 header line.
  # If there is less than 7 line, raise an exception.
  header_count = get_header_count(lines)
  # filter out the lines that are not inline tests
  # those with no line number
  # lines = tuple(filter(lambda l: l.n is not None, lines))
  # fixing the `what` of all the lines
  prepare_test_lines(lines)

  ans = []
  if len(tuple(filter(lambda l: l.n is not None, lines))):
    describe = """import * as mochai from "{(path_test / 'mochai').relative_to(path.parent)}"
""" f'describe(`Inline tests at {path.relative_to(path_js)}`' ''', function () {
  this.timeout(20000)
  beforeEach (function () { mochai.setup() })
  mochai.onrModel = eYo.NA
  mochai.setup()'''
    depth = 1
    test_header_count = 7
    for l in lines:
      if l.header:
        if test_header_count:
          test_header_count -= 1
          continue
        ans.append('//')
      elif test_header_count:
        for i in range(test_header_count):
          ans.append('//')
        test_header_count = 0
      if l.begin is not None:
        for x in l.what:
          if x == l.what[-1] and x == '../':
            ans.append('//')
            pass
          else:
            if describe is not None:
              ans.append(describe)
              describe = None
            name = 'describe' if l.describe or x != l.what[-1] else 'it'
            ans.append('  '*depth + f'{name}(`{x}`, function () {{')
            depth += 1
      elif l.cont is not None:
        ans.append('  ' * depth + l.indent + l.cont)
      elif l.n is not None:
        for x in l.what:
          if x == l.what[-1] and x == '../':
            ans.append('//')
            pass
          else:
            depth -= 1
            ans.append('  '*depth + f'}})')
      else:
        ans.append('//  '+l.code)
    ans.append('''
})
''')
  return '\n'.join(ans)

def base(p, ext=None):
  return (p.parent / (p.stem.split('.')[0])).with_suffix(ext or p.suffix)

def get_tests_ts_js():
  not_tests = tuple(p for p in path_js.rglob('*.test.*[tj]s') if p.is_file())
  tests_ts = set(OrderedDict((base(p), 0)
    for p in path_js.rglob('*.ts')
    if p.is_file() and not p in not_tests
  ).keys())
  not_tests_js = tuple((x.parent / x.stem).with_suffix('.js') for x in tests_ts)
  tests_js = set(OrderedDict((p, 0)
    for p in path_js.rglob('*.js')
    if p.is_file()
      and not p in not_tests_js
      and not p in not_tests
      and not base(p, '.ts') in tests_ts
  ).keys())
  return (*tests_ts, *tests_js)

def update_inline_test():
  print(format.title('Updating inline tests...'))
  update = []
  for p_test in get_tests_ts_js():
    p_ext = p_test.suffix
    p_base = p_test.parent / (p_test.stem.split('.')[0])
    p_inline = p_base.with_suffix('.test.inline' + p_ext)
    try:
      if p_test.stat().st_mtime < p_inline.stat().st_mtime:
        print(f'Skip {p_inline.relative_to(path_js)}')
        continue
    except: pass
    it = getInlineTest(p_test)
    if len(it):
      #print(format.emph(f'Update {p_inline.relative_to(path_js)}'))
      update.append(f'Update {p_inline.relative_to(path_js)}')
      p_inline.write_text(f'// This file was updated by "test.py" on {datetime.datetime.utcnow()}\n\n' + it)
    else:
      try:
        p_inline.unlink()
      except FileNotFoundError:
        pass
    break
  for p in update:
    print(format.emph(p))

  print(format.ok('... DONE'))
  return 0

